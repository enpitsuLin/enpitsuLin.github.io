<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>node-sass 安装失败解决方案</title>
      <link href="/2020/08/14/node-sass-install-fail/"/>
      <url>/2020/08/14/node-sass-install-fail/</url>
      
        <content type="html"><![CDATA[<h1 id="node-sass"><a href="#node-sass" class="headerlink" title="node-sass"></a>node-sass</h1><p>node-sass是我们开发中很常见的依赖包，也是安装时间冗长和最常见到报错的依赖。无论是自己的项目想要使用还是使用他人的项目进行依赖安装,运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><p>总是会出大大小小的毛病</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>遇到问题肯定是找搜索引擎啊,基本检索node-sass就会出现[失败,fail]等关键词联想=。=说明这个问题真的是非常普遍。然后简单记录下各种方法还有自己的方法。</p><h2 id="这里是一些前人经验"><a href="#这里是一些前人经验" class="headerlink" title="这里是一些前人经验:"></a>这里是一些前人经验:</h2><h2 id="因为npm源速度慢导致的下载失败"><a href="#因为npm源速度慢导致的下载失败" class="headerlink" title="因为npm源速度慢导致的下载失败"></a>因为npm源速度慢导致的下载失败</h2><p>一般来说都是推荐直接使用cnpm下载能够改善</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install </span><br></pre></td></tr></table></figure><p>或者更改源设置更完美,没有一些隐性bug出现.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><h3 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h3><p>或者可以仅将node-sass的下载源更改成淘宝镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set sass-binary-site http://npm.taobao.org/mirrors/node-sass</span><br></pre></td></tr></table></figure><h2 id="因为二进制文件源访问速度慢或无法访问"><a href="#因为二进制文件源访问速度慢或无法访问" class="headerlink" title="因为二进制文件源访问速度慢或无法访问"></a>因为二进制文件源访问速度慢或无法访问</h2><p>node-sass除了npm部分的代码，还会下载二进制文件，但是默认源是github，总所周知,github国内访问较慢,特殊时期甚至无法访问。我们也可以将其改成国内源,直接添加一条环境变量:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set SASS_BINARY_SITE=https://npm.taobao.org/mirrors/node-sass/ &amp;&amp; npm install node-sass</span><br></pre></td></tr></table></figure><p>或者可以在项目内添加一条<code>.npmrc</code> 文件然后添加</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sass_binary_site=https:<span class="regexp">//</span>npm.taobao.org<span class="regexp">/mirrors/</span>node-sass/</span><br></pre></td></tr></table></figure><p>这样使用npm安装node-sass时就会去淘宝镜像下载二进制文件了.</p><h1 id="最终解决方法"><a href="#最终解决方法" class="headerlink" title="最终解决方法"></a>最终解决方法</h1><p>最终解决方法!使用梯子并设置代理</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm config set proxy http://127.0.0.1:#你梯子开启的本地端口#</span><br><span class="line">npm install node-sass</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载完成后删除 http 代理</span></span><br><span class="line">npm config delete proxy</span><br></pre></td></tr></table></figure><h1 id="特殊手段解决"><a href="#特殊手段解决" class="headerlink" title="特殊手段解决"></a>特殊手段解决</h1><p>如果是因为下载失败的原因,那么我们可以提前下载到本地,先是查询系统的版本确定适合哪个版本的二进制文件.</p><p>查询指令如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node -p &quot;[process.platform, process.arch, process.versions.modules].join(&#x27;-&#x27;)&quot;</span><br></pre></td></tr></table></figure><p>然后会弹出<code>win32-x64-83</code>形式的系统版本,然后在下面两个地址中选择一个去下载对应系统版本的后缀为 .node 的 node-sass 文件</p><blockquote><p>cnpm <a href="https://npm.taobao.org/mirrors/node-sass/">https://npm.taobao.org/mirrors/node-sass/</a></p><p>github <a href="https://github.com/sass/node-sass/releases">https://github.com/sass/node-sass/releases</a></p></blockquote><p>然后我们需要手动指定 node-sass 二进制文件的下载源为下载的那个文件.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config set sass-binary-path 你存放刚才下载的二进制文件的目录</span><br><span class="line">// 例如 npm config set sass-binary-path e:/web/win32-x64-48_binding.node</span><br></pre></td></tr></table></figure><p>然后<code>npm i</code>应该就完事了,但是这个方法的确定就是无法更新node-sass的版本了,建议前面的方法都解决不了在尝试.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解Node.js的事件驱动模型</title>
      <link href="/2020/07/25/event-driven-model/"/>
      <url>/2020/07/25/event-driven-model/</url>
      
        <content type="html"><![CDATA[<h2 id="0x0"><a href="#0x0" class="headerlink" title="0x0"></a>0x0</h2><blockquote><p>Node.js 是单进程单线程应用程序，但是因为 V8 引擎提供的异步执行回调接口，通过这些接口可以处理大量的并发，所以性能非常高。</p></blockquote><p>首先由于V8引擎的卓越性能，以及大多数的GUI都才用事件驱动模型来响应用户事件，所以node的事件循环是使用了事件驱动模型。</p><h2 id="0x1-Model"><a href="#0x1-Model" class="headerlink" title="0x1 Model"></a>0x1 Model</h2><p>什么叫事件驱动模型？我们传统的事件处理模型的是线性的。就如同小学时的烧开水问题，线性的处理事件是单线程的。</p><blockquote><p>开始→烧开水→切菜→……→结束</p></blockquote><p>整个事件处理上是线性的，这样的处理模型是实现难度很低，开发很容易的。一个我将需要的任务一个个的做完这是最容易想到的办法 <del>相应的多线程就是多个我来干活XD</del></p><p>但是来到事件驱动模型上，我们首先接收到事件，但并不进行处理，而是将其放入一个事件队列，然后继续接收事件请求。</p><p>当没有事件时，再转到事件队列进行处理。如下的处理流程</p><blockquote><p>开始→烧开水（不需要人一直在）　　　　　→　结束<br><br>　　　　　　→　切菜　→　继续别的任务</p></blockquote><p>多个任务交错执行，但还是只有我一个人来做任务。在事件循环中查询所有的事件，然后当需要的时候将其分配给等待处理事件的函数（当任务需要的时候再由本人进行操作），这样就可以让整个流程尽可能快的执行且不需要额外的线程<del>人手</del></p><h2 id="0x2-Model-in-Node-js"><a href="#0x2-Model-in-Node-js" class="headerlink" title="0x2 Model in Node.js"></a>0x2 Model in Node.js</h2><p>众所周知的node.js作为一个单进程单线程程序，我们的js会运行在单个进程的单个线程上。首先严格意义上来讲。nodejs不是单线程架构，因为他有I/O线程，定时器线程等等，只不过这些都是由更底层的libuv处理，libuv将执行结果放入到队列中等待执行，这就来到了nodejs的事件循环了。</p><p>从Node.js运行，就将会初始化事件循环。事件循环大致可以分为六个阶段</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   ┌───────────────────────────┐</span><br><span class="line">┌─&gt;│           timers          │</span><br><span class="line">│  └─────────────┬─────────────┘</span><br><span class="line">│  ┌─────────────┴─────────────┐</span><br><span class="line">│  │     pending callbacks     │</span><br><span class="line">│  └─────────────┬─────────────┘</span><br><span class="line">│  ┌─────────────┴─────────────┐</span><br><span class="line">│  │       idle, prepare       │</span><br><span class="line">│  └─────────────┬─────────────┘      ┌───────────────┐</span><br><span class="line">│  ┌─────────────┴─────────────┐      │   incoming:   │</span><br><span class="line">│  │           poll            │&lt;─────┤  connections, │</span><br><span class="line">│  └─────────────┬─────────────┘      │   data, etc.  │</span><br><span class="line">│  ┌─────────────┴─────────────┐      └───────────────┘</span><br><span class="line">│  │          <span class="built_in"> check </span>          │</span><br><span class="line">│  └─────────────┬─────────────┘</span><br><span class="line">│  ┌─────────────┴─────────────┐</span><br><span class="line">└──┤      close callbacks      │</span><br><span class="line">   └───────────────────────────┘</span><br></pre></td></tr></table></figure><p>上述每一个阶段都会维护一个**<em>FIFO**</em>的可执行队列。</p><p>当事件循环进入到其中一个阶段时，其会执行该阶段的任何操作。直到这个阶段的任务队列为空，或者是回调函数的调用次数达到上限。此时事件循环将会到下一个阶段。</p><p><strong>各个阶段的介绍</strong></p><ol><li><p>timer：这个阶段执行通过setTimeout()和setInterval()设置的回调函数</p></li><li><p>I/O callback:执行延迟到下一个循环迭代的I/O回调</p></li><li><p>idle,prepare：系统调用，也就是liuv调用</p></li><li><p>poll:轮询阶段，检测新的I/O事件，执行与I/O相关的回调，（几乎所有的回调都是关闭回调，定时器调度的回调，以及setImmaditate()）,node会在此阶段适当的阻塞</p></li><li><p>check：此阶段调用setImmadiate()设置的回调</p></li><li><p>close callbacks：一些关闭回调，比如说socket.on(‘close’,…)</p></li></ol><hr><p>对于Node.js的事件驱动模型，我们的主要处理在于poll轮询阶段。当node.js在这个阶段读取到一个事件时，将调用与这个事件关联的回调函数，然后继续到队列中查看是否有下一个事件，如果有，就处理这个事件，直至处理完当前的队列。</p><p>然后关键的来了，当之前与事件关联的回调函数操作完后，node.js会将执行回调函数的引用加入到事件队列中，由于事件循环每一轮每一轮都会来到轮询阶段检测事件，就会检测到新的这个事件，完成全部的处理。</p><p>事件循环的模型可以简单视为下图</p><p><img src="/.io//event_loop.jpg" alt="事件循环"></p><h1 id="0x3-End"><a href="#0x3-End" class="headerlink" title="0x3 End"></a>0x3 End</h1><p>回到最初 我们用的栗子。一个人做一个清单的任务，有几种处理方式其实分别对应单线程、多线程以及事件驱动编程模型。其实可以让我们用例子来比较和对比一下单线程、多线程以及事件驱动编程模型。下图中展示了随着时间的推移，这三种模式下程序所做的工作。这个程序有3个任务需要完成，每个任务都在等待I/O操作时阻塞自身。阻塞在I/O操作上所花费的时间已经用灰色框标示出来了。</p><p><img src="/.io//three_type.png" alt="三种类型编程模型的对比"></p><blockquote><p><strong>单线程同步模型</strong><br><br>任务按照顺序执行。如果某个任务因为I/O而阻塞，其他所有的任务都必须等待，直到它完成之后它们才能依次执行。这种明确的执行顺序和串行化处理的行为是很容易推断得出的。如果任务之间并没有互相依赖的关系，但仍然需要互相等待的话这就使得程序不必要的降低了运行速度。</p></blockquote><blockquote><p><strong>多线程版本</strong><br><br>这3个任务分别在独立的线程中执行。这些线程由操作系统来管理，在多处理器系统上可以并行处理，或者在单处理器系统上交错执行。这使得当某个线程阻塞在某个资源的同时其他线程得以继续执行。与完成类似功能的同步程序相比，这种方式更有效率，但程序员必须写代码来保护共享资源，防止其被多个线程同时访问。多线程程序更加难以推断，因为这类程序不得不通过线程同步机制如锁、可重入函数、线程局部存储或者其他机制来处理线程安全问题，如果实现不当就会导致出现微妙且令人痛不欲生的bug。</p></blockquote><blockquote><p><strong>事件驱动模型</strong><br><br>在事件驱动版本的程序中，3个任务交错执行，但仍然在一个单独的线程控制中。当处理I/O或者其他昂贵的操作时，注册一个回调到事件循环中，然后当I/O操作完成时继续执行。回调描述了该如何处理某个事件。事件循环轮询所有的事件，当事件到来时将它们分配给等待处理事件的回调函数。这种方式让程序尽可能的得以执行而不需要用到额外的线程。事件驱动型程序比多线程程序更容易推断出行为，因为程序员不需要关心线程安全问题。</p></blockquote><hr><p><strong>优缺点补充：</strong></p><blockquote><p>以下内容来自<a href="https://blog.csdn.net/jmxyandy/article/details/7338889">https://blog.csdn.net/jmxyandy/article/details/7338889</a></p></blockquote><p><strong>ThreadPerConnection的多线程模型（比如Java）</strong><br>优点：简单易用，效率也不错。在这种模型中，开发者使用同步操作来编写程序，比如使用阻塞型I/O。使用同步操作的程序能够隐式地在线程的运行堆栈中维护应用程序的状态信息和执行历史，方便程序的开发。</p><p>缺点：没有足够的扩展性。如果应用程序只需处理少量的并发连接，那么对应地创建相应数量的线程，一般的机器都还能胜任；但如果应用程序需要处理成千上万个连接，那么为每个连接创建一个线程也许是不可行的。</p><p><strong>事件驱动的单线程模型</strong><br>优点：扩展性高，通常性能也比较好。在这种模型中，把会导致阻塞的操作转化为一个异步操作，主线程负责发起这个异步操作，并处理这个异步操作的结果。由于所有阻塞的操作都转化为异步操作，理论上主线程的大部分时间都是在处理实际的计算任务，少了多线程的调度时间，所以这种模型的性能通常会比较好。</p><p>缺点：要把所有会导致阻塞的操作转化为异步操作。一个是带来编程上的复杂度，异步操作需要由开发者来显示地管理应用程序的状态信息和执行历史。第二个是目前很多广泛使用的函数库都很难转为用异步操作来实现，即是可以用异步操作来实现，也将进一步增加编程的复杂度。</p><p><strong>并发系统通常既包含异步处理服务，又包含同步处理服务。系统程序员有充分的理由使用异步特性改善性能。相反，应用程序员也有充分的理由使用同步处理简化他们的编程强度。</strong></p><hr><p>所以当我们面对如下的环境时，事件驱动模型通常是一个好的选择：</p><ul><li>程序中有许多任务，而且…</li><li>任务之间高度独立（因此它们不需要互相通信，或者等待彼此）而且…</li><li>在等待事件到来时，某些任务会阻塞。</li></ul><p><em>参考资料</em></p><ul><li><a href="https://www.jianshu.com/p/9faada4cd977">https://www.jianshu.com/p/9faada4cd977</a></li><li><a href="https://www.runoob.com/nodejs/nodejs-event-loop.html">https://www.runoob.com/nodejs/nodejs-event-loop.html</a></li><li><a href="https://www.jdon.com/idea/nodejs/tutorial.html">https://www.jdon.com/idea/nodejs/tutorial.html</a></li><li><a href="https://www.jianshu.com/p/4de50514ea7f">https://www.jianshu.com/p/4de50514ea7f</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> GUI </tag>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cocos2d手游逆向——XXTEA加密</title>
      <link href="/2020/04/03/cocos2d-decrypt/"/>
      <url>/2020/04/03/cocos2d-decrypt/</url>
      
        <content type="html"><![CDATA[<p>因为最近在玩一款挂机类的手机游戏，但是玩的挺难受，网上搜了几篇文章，起了点逆向的兴趣。</p><p>遂拿起半吊子的技术尝试照猫画虎。</p><a id="more"></a><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>先是将手机安装的APK文件导出，直接adb pull将/data/app里的APK文件拉取。</p><p>然后解压查看lib目录发现<br><img src="/.io//lib%E7%9B%AE%E5%BD%95.jpg" alt="lib目录"><br>很明显这是一款基于cocos2dlua开发的手游，然后来到\assets\src目录下</p><p><img src="/.io//src%E7%9B%AE%E5%BD%95.png" alt="src目录"><br>不过直接打开显示乱码，显然是经过加密的。</p><h2 id="前期思考"><a href="#前期思考" class="headerlink" title="前期思考"></a>前期思考</h2><p>网上搜索cocos2d加密，根据文件的内容结构，应该是以cocos2dlua默认的加密方法XXTEA算法进行加密的。</p><p>这种算法拥有相应的标识符和密钥，所以被加密的lua文件开头的一串<code>FF98392D</code>应该就是相应的标识<br><img src="/.io//sign%E6%A0%87%E8%AF%86.png" alt="sign标识"></p><p>接下来需要拿到密钥，直接拿起IDA对cocos2dlua.so进行调试。用IDA打开so等待自动分析完成，然后建立string list，直接搜索这个标识<code>FF98392D</code><br><img src="/.io//%E5%AE%9A%E4%BD%8D%E5%88%B0%E5%AF%86%E9%92%A5%E5%92%8C%E6%A0%87%E8%AF%86.png" alt="定位到密钥和标识"></p><p>可以看到一个奇怪的字符串witu_xxWEM，然后使用网上下载的XXTEADecrypt软件进行解码。</p><p>然后心满意足的打开.lua脚本，惊讶的发现还是不可读的乱码。<br><img src="/.io//%E4%B9%B1%E7%A0%81.png" alt="还是乱码"></p><p>不过这个文件的前几个字节还是一样的有标识<code>LJ</code> 所以我想是不是还是经过了一层XXTEA的加密。</p><p>于是我将<code>LJ</code>当做标识,IDA里继续搜索<code>LJ</code>获得Key，但是这次没有一个看似正确的结果。于是只能对汇编的代码进行分析。</p><h2 id="半吊子汇编"><a href="#半吊子汇编" class="headerlink" title="半吊子汇编"></a>半吊子汇编</h2><p>在查阅cocos2dlua的资料后，我知道程序载入资源基本是通过luaLoadBuffer，许多直接hook函数解码的方法也是对该函数进行hook。</p><p>于是我就搜索luaLoadBuffer这个函数，与源码比对，发现似乎有点不一样。似乎是定义了自己的函数对密钥进行操作然后再调用官方的decrypt()</p><p>不过找了好久都没有头绪</p><h2 id="豁然开朗"><a href="#豁然开朗" class="headerlink" title="豁然开朗"></a>豁然开朗</h2><p>因为分析了半天还是没有得出有用的结论，开始在搜索引擎上瞎找。</p><p>然后在搜索LJ+cocos关键词发现，用UltraEdit打开前几个字节是LJ的话，说明这个文件是通过LuaJIT编译后的文件。</p><p>所以思路就不对(〃＞皿＜)</p><h2 id="结局"><a href="#结局" class="headerlink" title="结局"></a>结局</h2><p>网上对Luajit的相关资料都好老，下次再慢慢整。</p><p>然后完全第一次搞逆向玩，了解到IDA这个神奇的工具，心想大概还需要汇编方面的知识，有机会这次之后好好学习。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 逆向 </tag>
            
            <tag> 安卓 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客迁移到gitee</title>
      <link href="/2020/03/27/migration-to-gitee/"/>
      <url>/2020/03/27/migration-to-gitee/</url>
      
        <content type="html"><![CDATA[<p>github 在国内是越来越难访问，闲的蛋疼就把这个博客迁移到gitee上，现在访问速度终于可以接受了</p><p>码云<sup>TM</sup>，虽然听着像某位老板XD<del>马云</del></p><p>不过与github关联后可以直接从github克隆仓库，这样也是十分省事，虽然该博客项目还是重新创建仓库然后重新发布的XD</p><p>鉴于github的公认度，估计以后的学习中的项目还是会部署一份到github上</p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> blog </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Window下配置你的shell</title>
      <link href="/2019/03/28/config-powershell/"/>
      <url>/2019/03/28/config-powershell/</url>
      
        <content type="html"><![CDATA[<p><strong>终端</strong>，是用户与操作系统进行交互的最原始的输入输出环境，也是一些高级系统操作必要工具。<br>经常调试脚本，使用git频率多，于是今天决定配一个好用的shell来当做学习环境。</p><a id="more"></a><p>下面就开始调教window10自带的其实十分强大<del>但是有点丑</del>的 <strong>powershell</strong></p><h2 id="更换-PowerShell-的配色"><a href="#更换-PowerShell-的配色" class="headerlink" title="更换 PowerShell 的配色"></a>更换 PowerShell 的配色</h2><p>微软官方提供了一个更换 PowerShell 配色的小工具：ColorTool.exe，我们可以利用它来更换 PowerShell 的主题颜色。</p><p>我们可以从 ColorTool 的 <a href="https://github.com/Microsoft/console/releases">GitHub 页面</a> 下载这个小工具。当然，如果你使用 Scoop 或者 Chocolatey，也可以这样安装：</p><p>Scoop</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scoop install colortool</span><br></pre></td></tr></table></figure><p>Chocolatey</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">choco install colortool</span><br></pre></td></tr></table></figure><p>这里我更加推荐利用 <strong>Scoop</strong> 这个优质的包管理来安装 ColorTool。</p><hr><p>ColorTool 使用非常简单。我们可以利用下面这个命令进行查看工具自带的几个主题：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 注：-s 代表 schemes</span></span><br><span class="line">colortool -s</span><br></pre></td></tr></table></figure><img src="/2019/03/28/config-powershell/%E5%87%A0%E4%B8%AA%E8%87%AA%E5%B8%A6%E9%85%8D%E8%89%B2%E4%B8%BB%E9%A2%98.png" class="" title="[几个自带配色主题]"><p>前面的几个 .ini 和 .itermcolors就是主题配置文件，我们可以直接通过下面这个命令设置主题：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 临时查看</span></span><br><span class="line">colortool &lt;主题名称&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 定义默认值</span></span><br><span class="line">colortool -d &lt;主题名称&gt;</span><br></pre></td></tr></table></figure><p>比如我们希望将主题配色更换为<br>OneHalfDark.itermcolors，只需要输入下面这个命令就可以更换并预览更新：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">colortool OneHalfDark</span><br></pre></td></tr></table></figure><blockquote><p>由于 ColorTool 直接支持 iTerm 主题配置文件，因此我们可以在 iterm2colorschemes 这个网站找到我们想要的主题背景进行配置，方法和上面介绍的一样：在 PowerShell 中定位至你希望更换的主题文件，使用命令 <code>colortool &lt;主题名称&gt;.itermcolors</code> 进行配置即可。同时，如果你对上面的主题都不满意，你也可以直接在这个网站： terminal.sexy 自行配置自己想要的主题，并通过同样的方式进行应用。</p></blockquote><h2 id="改进-PowerShell-的字体"><a href="#改进-PowerShell-的字体" class="headerlink" title="改进 PowerShell 的字体"></a>改进 PowerShell 的字体</h2><p>对于大多数人来说默认 PowerShell 的<code>新宋体</code>真的是十分的丑。<br>由于微软对控制台字体的元数据有限制：</p><blockquote><p>这些字体必须满足以下条件，可在命令会话窗口中：<br>　该字体必须是等宽字体。<br>　该字体不能为斜体字体。<br>　该字体不能有A或C负空间。<br>　如果是 TrueType 字体，则它必须是 FF_MODERN。<br>　如果它不是 TrueType 字体，则它必须是 OEM_CHARSET。<br>对于亚洲字体的附加条件：<br>　如果不是 TrueType 字体，字体名必须是“Terminal”。<br>　如果它是亚洲的 TrueType 字体，它还必须使用亚洲语言的字符集。</p></blockquote><p>可能大多数人喜欢使用适合于编程的等宽字体如 Consolas 作为Powershell的字体,但这里推荐一款<code>Sarasa Gothic / 更纱黑体 / 更紗黑體 / 更紗ゴシック</code>(更纱黑体)，可以从更纱黑体的 <a href="https://github.com/be5invis/Sarasa-Gothic/releases">GitHub 页面</a>下载。</p><p>下载解压安装更纱黑体之后，我们重新启动一个 PowerShell 终端，就可以在菜单栏右键，选择<code>属性-字体</code>，并在字体中选择更纱黑体。适合终端使用的等宽字体是<code>等距更纱黑体 T SC</code>或<code>Sarasa Mono T SC</code>。</p><p>至此字体就从别扭的<code>新宋体</code>改到了<code>更纱黑体</code></p><h2 id="定制-PowerShell-中的-Prompt-单元"><a href="#定制-PowerShell-中的-Prompt-单元" class="headerlink" title="定制 PowerShell 中的 Prompt 单元"></a>定制 PowerShell 中的 Prompt 单元</h2><p>PowerShell 等 Shell 的一个基本的命令单元大致如下：</p><ul><li>前面的部分就是 Prompt，能够展示包括用户、系统、开发环境、版本控制等等有用的信息</li><li>后面的部分是具体的命令，也就是我们每次执行操作时输入命令的位置</li></ul><img src="/2019/03/28/config-powershell/Shell%E5%91%BD%E4%BB%A4%E7%BB%93%E6%9E%84.png" class="" title="Shell命令结构"><h3 id="安装-oh-my-posh"><a href="#安装-oh-my-posh" class="headerlink" title="安装 oh-my-posh"></a>安装 oh-my-posh</h3><p>我们需要先以管理员权限启动 PowerShell，以便执行安装操作。（具体是在开始按钮上点击右键，选择“Windows PowerShell (管理员)”。</p><p>然后，运行命令以安装 posh-git，这是 oh-my-posh 的依赖。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Install-Module posh-git -Scope CurrentUser</span><br></pre></td></tr></table></figure><p>如果此前没有安装 NuGet 提供程序，则此时会提示安装 NuGet；如果此前没有开启执行任意脚本，此处也会提示执行脚本。如果没有权限执行脚本，可能需要先执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-ExecutionPolicy Bypass</span><br></pre></td></tr></table></figure><p>接下来，运行命令以安装 oh-my-posh 本身。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Install-Module oh-my-posh  -Scope CurrentUser </span><br></pre></td></tr></table></figure><p>到这里oh-my-posh就安装完毕</p><hr><h3 id="配置-oh-my-posh"><a href="#配置-oh-my-posh" class="headerlink" title="配置 oh-my-posh"></a>配置 oh-my-posh</h3><p>接下来，我们需要对oh-my-posh进行配置<br>首先</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (!(Test-Path -Path $PROFILE )) &#123; New-Item -Type File -Path $PROFILE -Force &#125;</span><br><span class="line">notepad $PROFILE</span><br></pre></td></tr></table></figure><p>然后再打开的记事本文档中添加下列内容</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Import</span>-<span class="keyword">Module</span> posh-git </span><br><span class="line"><span class="keyword">Import</span>-<span class="keyword">Module</span> oh-my-posh </span><br><span class="line"><span class="keyword">Set</span>-Theme Agnoster</span><br></pre></td></tr></table></figure><p>如果一切顺利的话重启你的 Powershell 就会发现已经变得和本节开头的示意图一样了。</p><hr><p>PS：配置文件的最后一句<code>Set-Theme  Agnoster</code>的作用就是配置主题。我们可以在配置文件里面修改这个命令中的 Agnoster 即「主题名」来更换主题。更多的主题可以<a href="https://github.com/JanDeDobbeleer/oh-my-posh#themes">oh-my-posh 的文档#主题</a>中查看。</p><h2 id="使用第三方终端与-Powershell-协同工作"><a href="#使用第三方终端与-Powershell-协同工作" class="headerlink" title="使用第三方终端与 Powershell 协同工作"></a>使用第三方终端与 Powershell 协同工作</h2><p>现在我所使用的和文章内截图所示的都是基于ConEmu+Powershell的效果<br><del>咕咕咕</del></p><h3 id="更贴近win10风格的第三方终端"><a href="#更贴近win10风格的第三方终端" class="headerlink" title="更贴近win10风格的第三方终端"></a>更贴近win10风格的第三方终端</h3><h4 id="Fluent-Terminal"><a href="#Fluent-Terminal" class="headerlink" title="Fluent Terminal"></a>Fluent Terminal</h4><p>试用一段时间弃，确实很华丽。</p><h4 id="Hyper"><a href="#Hyper" class="headerlink" title="Hyper"></a>Hyper</h4><p>未尝试</p><h4 id="Terminus"><a href="#Terminus" class="headerlink" title="Terminus"></a>Terminus</h4><p>未尝试</p><h3 id="ConEmu"><a href="#ConEmu" class="headerlink" title="ConEmu"></a>ConEmu</h3><h2 id="使用WSL-zsh"><a href="#使用WSL-zsh" class="headerlink" title="使用WSL + zsh"></a>使用WSL + zsh</h2><p>这方面我也不是很懂.jpg 留个位置以后有机会试试</p><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>至此对win10的默认终端 Powershell 调教完成。然后享受吧。</p>]]></content>
      
      
      
        <tags>
            
            <tag> shell </tag>
            
            <tag> winodws </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新增一个live2d插件</title>
      <link href="/2019/03/27/add-live2d-model/"/>
      <url>/2019/03/27/add-live2d-model/</url>
      
        <content type="html"><![CDATA[<p>基于这几天对于hexo这个简单强大的框架的热度,折腾了一些时间,暂时就成了现在的样子.</p><p>但似乎感觉少了点什么,于是往页面上<code>hexo-helper-live2d</code></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>使用终端命令在项目内安装模块</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-helper-live2d</span><br></pre></td></tr></table></figure><p>以及安装所需的live2d模型,这里我选用的是一个简单的黑猫模型.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install live2d-widget-model-hijiki</span><br></pre></td></tr></table></figure><p>安装完之后进行配置</p><p>往<code>_config.yml</code>文件中添加下列语句</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Live2D</span></span><br><span class="line"><span class="attr">live2d:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">model:</span></span><br><span class="line">    <span class="attr">use:</span> <span class="string">live2d-widget-model-hijiki</span></span><br><span class="line">  <span class="attr">display:</span></span><br><span class="line">    <span class="attr">width:</span> <span class="number">100</span></span><br><span class="line">    <span class="attr">height:</span> <span class="number">200</span></span><br><span class="line">    <span class="attr">position:</span> <span class="string">left</span></span><br><span class="line">    <span class="attr">hOffset:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">vOffset:</span> <span class="number">-90</span></span><br><span class="line">  <span class="attr">mobile:</span></span><br><span class="line">    <span class="attr">show:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>完成配置</p><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>然后直接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s -g</span><br></pre></td></tr></table></figure><p>然后在<code>http://localhost:4000/</code>进行预览然后可以<code>hexo d</code>部署到服务器上查看</p><hr><p><a href="https://github.com/EYHN/hexo-helper-live2d">原作者仓库hexo-helper-live2d</a><br><a href="https://github.com/xiazeyu/live2d-widget-models">所用模型仓库</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> live2d </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/03/26/hello-world/"/>
      <url>/2019/03/26/hello-world/</url>
      
        <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">helloWorld</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>重新使用hexo以及gayhub page建立了一个记录生活的地方 完全重置.jpg</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
